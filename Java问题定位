常见Java问题定位工具:

Jstat –gcutil [PID]
初步定位Java应用是否存在内存问题
查看JVM堆内存使用是否正常
使用MAT分析异常的内存dump（使用Jmap导出）

Jstack [PID]
初步定位Java应用是否存在线程问题
查看线程状态是否存在阻塞、死锁
查看热点线程的调用树，判断可疑的业务代码
Jstack结果可视化查看工具——jca工具
死锁
     在线程jstack的栈信息里，有一段以下信息：
     Thread-1 持有  0x00000007d5df4970，等待获取：0x00000007d5df4960
     Thread-0 持有  0x00000007d5df4960，等待获取：0x00000007d5df4970
     线程Thread-1和线程Thread-0互相持有对方的锁，并等待对方释放锁，造成两个线程进入无限等待。
     这个现象称为死锁。



jmap -dump:live,format=b,file=dump.hprof [PID]
使用MAT分析dump文件

Jmc
初步判断是Java应用存在性能问题时，使用Jmc定位详细问题原因
GCLOG
稳定性测试、长时间测试时使用，记录Java应用内存变化趋势
Linux
      运行命令的用户必须和Java进程运行的用户一致。应用使用root用户启动，必须使用root用户运行Java工具。

Windows
      Windows下，要求与Linux是相同的，运行工具的用户与Java进程运行的用户一致。
      Windows用户体系与Linux不同，最高权限用户是System，Java应用已服务方式运行时，所属用户都是System。一般无法直接切换成System用户。
      使用PStool的PsExec来实现获取System权限
      在命令行中，使用PsExec.exe –s [Java工具绝对路径  Java工具参数]


现象一
    在设备接入框架执行1000个设备迁移时，平台10min没有响应。平台后端服务为tomcat
现象二
    查看服务器资源利用情况（通过Windows性能监视器或Zabbix）
    <资源监控图>

    linux使用top、vmstat、iostat等命令查看
现象三
    查看进程CPU资源利用情况
    <procexp图 进程,线程图>
    
tomcat的CPU利用率达到60.12%（linux可以使用top -H）
   使用procexp工具查看使用CPU的具体线程，发现是有多个线程消耗CPU都较多，但没有一个线程消耗CPU特别高的
现象四
    查看tomcat的JVM Heap的情况（jstat）
    <jstat监控图>
    看到这里，基本明白了出现了什么问题。JVM一直在FullGC，tomcat被挂起，无法响应业务。
    
现象五
    回过头查看tomcat的线程情况（jstack）
    使用jstack打印tomcat线程信息
    从现象三的找到的线程33048转成十六进制0x8118，查找线程对应的业务。
    <jstack图>
      果然看到是GC线程在消耗CPU。
      
现象六
    具体查看是什么原因导致了FullGC的产生
    使用jmap导出dump，通过MAT分析
<MAT图>
    MAT提示发现一个可疑的内存泄漏问题
    <MAT图2,显示类,堆,百分比等信息>
    <MAT图3,显示 对象,堆栈线程信息,>  找到哪个对象,代码消耗的堆最多

    https://www.cnblogs.com/android-blogs/p/5765148.html
    
    ---------------------------------------------------------------------------------
    
    8	并发登录时，并发数达到80TPS时，响应时间突然升高
8.1	现象
在吞吐量达到80TPS时，打开首页和登出的响应时间突然快速升高(Jmeter 监控)。

8.2	排查
查看服务器CPU和IO后，发现没有异常（CPU在30%，队列长度接近1，IO较小，队列长度接近0）

由于操作系统层没有明显的异常，出问题的是tomcat，下一步对tomcat抓了一个线程dump。查看dump内容，发现有一个BLOCKED状态的线程
"http-nio-8080-exec-43" #149 daemon prio=5 os_prio=0 tid=0x0000000010947000 nid=0x2898 waiting for monitor entry [0x00000000273ac000]
   java.lang.Thread.State: BLOCKED (on object monitor)
	at java.io.PrintStream.write(PrintStream.java:478)
	- waiting to lock <0x0000000080050520> (a java.io.PrintStream)
	…
锁lock< 0x0000000080050520>如下
"http-nio-8080-exec-18" #123 daemon prio=5 os_prio=0 tid=0x00000000121c9000 nid=0x4b40 runnable [0x0000000025dad000]
   java.lang.Thread.State: RUNNABLE
	at java.io.FileOutputStream.writeBytes(Native Method)
	at java.io.FileOutputStream.write(FileOutputStream.java:326)
	at java.io.BufferedOutputStream.write(BufferedOutputStream.java:122)
	- locked <0x0000000080050540> (a java.io.BufferedOutputStream)----------------------here
	at java.io.PrintStream.write(PrintStream.java:480)
	- locked <0x0000000080050520> (a java.io.PrintStream)----------------------here
	at org.apache.tomcat.util.log.SystemLogHandler.write(SystemLogHandler.java:177)
	at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)at java.io.PrintStream.write(PrintStream.java:480)
	- locked <0x0000000080050520> (a java.io.PrintStream)
	at org.apache.tomcat.util.log.SystemLogHandler.write(SystemLogHandler.java:177)
	at sun.nio.cs.StreamEncoder.writeBytes(StreamEncoder.java:221)
	at sun.nio.cs.StreamEncoder.implFlushBuffer(StreamEncoder.java:291)
	at sun.nio.cs.StreamEncoder.implFlush(StreamEncoder.java:295)
	at sun.nio.cs.StreamEncoder.flush(StreamEncoder.java:141)
	- locked <0x0000000081ada7f0> (a java.io.OutputStreamWriter)
	at java.io.OutputStreamWriter.flush(OutputStreamWriter.java:229)
	at org.apache.log4j.helpers.QuietWriter.flush(QuietWriter.java:57)----------------------日志相关
	at org.apache.log4j.WriterAppender.subAppend(WriterAppender.java:315)
	at org.apache.log4j.WriterAppender.append(WriterAppender.java:159)
	at org.apache.log4j.AppenderSkeleton.doAppend(AppenderSkeleton.java:230)
	- locked <0x0000000081ad9bf8> (a org.apache.log4j.ConsoleAppender)
	at org.apache.log4j.helpers.AppenderAttachableImpl.appendLoopOnAppenders(AppenderAttachableImpl.java:65)
	at org.apache.log4j.Category.callAppenders(Category.java:203)
	- locked <0x0000000081ab9f28> (a org.apache.log4j.spi.RootLogger)
	at org.apache.log4j.Category.forcedLog(Category.java:388)
	at org.apache.log4j.Category.info(Category.java:663)


8.3	解决方案
1.将同步写日志改成异步写

